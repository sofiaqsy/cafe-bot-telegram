import os\nimport logging\nimport datetime\nimport string\nimport random\nimport json\nfrom typing import Dict, List, Any, Optional, Union\nimport googleapiclient.discovery\nfrom google.oauth2 import service_account\nfrom config import SPREADSHEET_ID, GOOGLE_CREDENTIALS\n\n# Configurar logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Definir constantes\nFASES_CAFE = [\"CEREZO\", \"MOTE\", \"PERGAMINO\", \"TOSTADO\", \"MOLIDO\"]\n\n# Definir transiciones válidas entre fases\nTRANSICIONES_PERMITIDAS = {\n    \"CEREZO\": [\"MOTE\"],\n    \"MOTE\": [\"PERGAMINO\"],\n    \"PERGAMINO\": [\"TOSTADO\", \"MOLIDO\"],  # Permitir transición directa a MOLIDO\n    \"TOSTADO\": [\"MOLIDO\"]\n}\n\n# Cabeceras para las hojas\nHEADERS = {\n    \"compras\": [\"id\", \"fecha\", \"proveedor\", \"tipo_cafe\", \"fase_actual\", \"cantidad\", \"kg_disponibles\", \"precio\", \"total\", \"notas\", \"registrado_por\"],\n    \"proceso\": [\"fecha\", \"origen\", \"destino\", \"cantidad\", \"compras_ids\", \"merma\", \"notas\", \"registrado_por\"],\n    \"gastos\": [\"fecha\", \"categoria\", \"monto\", \"descripcion\", \"registrado_por\"],\n    \"ventas\": [\"fecha\", \"cliente\", \"tipo_cafe\", \"peso\", \"precio_kg\", \"total\", \"notas\", \"registrado_por\"],\n    \"pedidos\": [\"fecha\", \"cliente\", \"tipo_cafe\", \"cantidad\", \"precio_kg\", \"total\", \"estado\", \"fecha_entrega\", \"notas\", \"registrado_por\"],\n    \"adelantos\": [\"fecha\", \"hora\", \"cliente\", \"monto\", \"notas\", \"registrado_por\"],\n    \"almacen\": [\"id\", \"compra_id\", \"fase\", \"fecha\", \"cantidad\", \"fase_actual\", \"notas\"]\n}\n\n# Variables globales para el servicio de Google Sheets\n_sheet_service = None\n\ndef get_sheet_service():\n    \"\"\"Obtiene el servicio de Google Sheets, creándolo si es necesario\"\"\"\n    global _sheet_service\n    \n    if _sheet_service is None:\n        try:\n            # Si GOOGLE_CREDENTIALS es un string JSON, cargarlo como un dict\n            if GOOGLE_CREDENTIALS.startswith('{'):\n                credentials_info = json.loads(GOOGLE_CREDENTIALS)\n            else:\n                # Si es un path a un archivo, cargarlo\n                with open(GOOGLE_CREDENTIALS, 'r') as f:\n                    credentials_info = json.load(f)\n            \n            # Crear credenciales a partir de la información\n            credentials = service_account.Credentials.from_service_account_info(\n                credentials_info, scopes=['https://www.googleapis.com/auth/spreadsheets']\n            )\n            \n            # Crear servicio\n            _sheet_service = googleapiclient.discovery.build('sheets', 'v4', credentials=credentials)\n            logger.info(\"Servicio de Google Sheets inicializado correctamente\")\n        except Exception as e:\n            logger.error(f\"Error al inicializar el servicio de Google Sheets: {e}\")\n            raise\n    \n    return _sheet_service\n\ndef get_or_create_sheet():\n    \"\"\"Obtiene el ID de la hoja, verificando que exista y creándola si es necesario\"\"\"\n    # Por ahora, simplemente devolver el ID configurado\n    return SPREADSHEET_ID\n\ndef initialize_sheets():\n    \"\"\"Inicializa las hojas de Google Sheets con las cabeceras correctas\"\"\"\n    try:\n        sheets = get_sheet_service()\n        spreadsheet_id = get_or_create_sheet()\n        \n        # Obtener todas las hojas existentes\n        sheet_metadata = sheets.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n        existing_sheets = {sheet['properties']['title'] for sheet in sheet_metadata.get('sheets', [])}\n        \n        # Para cada hoja definida en HEADERS\n        for sheet_name, headers in HEADERS.items():\n            # Verificar si la hoja existe\n            if sheet_name not in existing_sheets:\n                # Crear la hoja\n                logger.info(f\"Creando hoja '{sheet_name}'...\")\n                requests = [{\n                    'addSheet': {\n                        'properties': {\n                            'title': sheet_name\n                        }\n                    }\n                }]\n                sheets.spreadsheets().batchUpdate(\n                    spreadsheetId=spreadsheet_id,\n                    body={'requests': requests}\n                ).execute()\n                \n                # Verificar si la hoja se creó correctamente\n                sheet_metadata = sheets.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n                updated_existing_sheets = {sheet['properties']['title'] for sheet in sheet_metadata.get('sheets', [])}\n                \n                if sheet_name in updated_existing_sheets:\n                    logger.info(f\"Hoja '{sheet_name}' creada correctamente\")\n                else:\n                    logger.error(f\"Error al crear la hoja '{sheet_name}'\")\n                    continue\n            \n            # Verificar si la hoja tiene cabeceras\n            range_name = f\"{sheet_name}!A1:Z1\"\n            result = sheets.values().get(\n                spreadsheetId=spreadsheet_id,\n                range=range_name\n            ).execute()\n            \n            values = result.get('values', [])\n            \n            if not values or len(values[0]) < len(headers):\n                # Escribir las cabeceras\n                logger.info(f\"Escribiendo cabeceras para la hoja '{sheet_name}'...\")\n                sheets.values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=range_name,\n                    valueInputOption=\"RAW\",\n                    body={\"values\": [headers]}\n                ).execute()\n                \n                logger.info(f\"Cabeceras para '{sheet_name}' actualizadas correctamente\")\n            else:\n                logger.info(f\"La hoja '{sheet_name}' ya tiene cabeceras\")\n            \n            # Operaciones especiales por tipo de hoja\n            if sheet_name == 'compras':\n                # Para compras existentes, asegurarse de que tengan un ID único\n                # Esto es para mantener compatibilidad con compras que no tenían ID\n                compras = get_all_data('compras')\n                for i, compra in enumerate(compras):\n                    if not compra.get('id'):\n                        # Generar un ID único\n                        nuevo_id = generate_unique_id()\n                        # Actualizar la compra\n                        update_cell('compras', compra['_row_index'], 'id', nuevo_id)\n                        logger.info(f\"Asignado ID {nuevo_id} a compra existente (fila {compra['_row_index'] + 2})\")\n            \n            elif sheet_name == 'almacen':\n                # Para el almacén, asegurarse de que todas las fases estén inicializadas\n                almacen_data = get_all_data('almacen')\n                fases_existentes = {str(item.get('fase', '')).strip().upper() for item in almacen_data}\n                \n                # Verificar si es necesario sincronizar\n                fases_faltantes = set(FASES_CAFE) - fases_existentes\n                if fases_faltantes:\n                    logger.info(f\"Inicializando fases faltantes en almacén: {fases_faltantes}\")\n                    \n                    now = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                    for fase in fases_faltantes:\n                        # Añadir la fase con cantidad 0\n                        append_data('almacen', {\n                            'id': generate_almacen_id(),\n                            'compra_id': '',\n                            'fase': fase,\n                            'fecha': now,\n                            'cantidad': 0,\n                            'fase_actual': fase,\n                            'notas': 'Inicialización automática'\n                        })\n        \n        logger.info(\"Inicialización de hojas completada correctamente\")\n        return True\n    except Exception as e:\n        logger.error(f\"Error al inicializar las hojas: {e}\")\n        return False\n\ndef generate_unique_id(length=6):\n    \"\"\"\n    Genera un ID único alfanumérico para compras\n    \n    Args:\n        length: Longitud del ID (default: 6)\n    \n    Returns:\n        str: ID único alfanumérico\n    \"\"\"\n    # Caracteres permitidos (letras mayúsculas y números)\n    chars = string.ascii_uppercase + string.digits\n    \n    # Generar un ID único con formato CP-XXXXXX (Café Purchase)\n    unique_id = 'CP-' + ''.join(random.choice(chars) for _ in range(length))\n    \n    return unique_id\n\ndef generate_almacen_id(length=6):\n    \"\"\"\n    Genera un ID único alfanumérico para registros del almacén\n    \n    Args:\n        length: Longitud del ID (default: 6)\n    \n    Returns:\n        str: ID único alfanumérico\n    \"\"\"\n    # Caracteres permitidos (letras mayúsculas y números)\n    chars = string.ascii_uppercase + string.digits\n    \n    # Generar un ID único con formato AL-XXXXXX (Almacén)\n    unique_id = 'AL-' + ''.join(random.choice(chars) for _ in range(length))\n    \n    return unique_id\n\ndef format_date_for_sheets(date_str):\n    \"\"\"\n    Formatea una fecha para evitar que Google Sheets la convierta automáticamente\n    \n    Args:\n        date_str: Fecha en formato YYYY-MM-DD\n    \n    Returns:\n        str: Fecha formateada para Google Sheets\n    \"\"\"\n    # Verificar formato\n    if isinstance(date_str, str) and len(date_str) == 10 and date_str[4] == '-' and date_str[7] == '-':\n        # Prefijo con comilla simple para forzar formato de texto en Google Sheets\n        return f\"'{date_str}'\"\n    return date_str\n\ndef append_data(sheet_name, data):\n    \"\"\"Añade una fila de datos a la hoja especificada\"\"\"\n    if sheet_name not in HEADERS:\n        logger.error(f\"Nombre de hoja inválido: {sheet_name}\")\n        raise ValueError(f\"Nombre de hoja inválido: {sheet_name}\")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        service = get_sheet_service()\n        \n        # Para compras, asegurar que tenga un ID único\n        if sheet_name == 'compras' and 'id' not in data:\n            data['id'] = generate_unique_id()\n            logger.info(f\"Generado ID único para compra: {data['id']}\")\n        \n        # Para almacén, asegurar que tenga un ID único\n        if sheet_name == 'almacen' and 'id' not in data:\n            data['id'] = generate_almacen_id()\n            logger.info(f\"Generado ID único para almacén: {data['id']}\")\n            \n            # Si no tiene fecha, agregar la fecha actual\n            if 'fecha' not in data or not data['fecha']:\n                data['fecha'] = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        # Convertir el diccionario a una lista ordenada según las cabeceras\n        headers = HEADERS[sheet_name]\n        row_data = []\n        \n        # Imprimir información detallada para depurar\n        logger.info(f\"Cabeceras para la hoja '{sheet_name}': {headers}\")\n        logger.info(f\"Datos recibidos: {data}\")\n        \n        # Verificar que todos los campos necesarios existan\n        for header in headers:\n            if header not in data or not data[header]:\n                logger.warning(f\"Campo '{header}' faltante o vacío en los datos. Usando valor por defecto.\")\n                \n                # Valores por defecto según el campo\n                if header == 'tipo_cafe':\n                    data[header] = \"No especificado\"\n                elif header in ['cantidad', 'precio', 'total', 'kg_disponibles', 'merma']:\n                    data[header] = \"0\"\n                elif header == 'fase_actual' and sheet_name == 'compras' and 'tipo_cafe' in data:\n                    # Si es una compra, la fase inicial es el tipo de café\n                    data[header] = data.get('tipo_cafe', \"No especificado\")\n                elif header == 'fase_actual' and sheet_name == 'almacen' and 'fase' in data:\n                    # Si es almacén, la fase_actual es la misma que la fase\n                    data[header] = data.get('fase', \"\")\n                else:\n                    data[header] = \"\"\n        \n        # Pre-procesamiento específico para el campo de fecha\n        # Para adelantos, asegurarnos de que las fechas tengan el formato correcto\n        if sheet_name == 'adelantos':\n            # Formatear explícitamente la fecha como texto para evitar que Sheets la convierta en número\n            if 'fecha' in data and data['fecha']:\n                data['fecha'] = format_date_for_sheets(data['fecha'])\n            \n            # Hacer lo mismo con la hora\n            if 'hora' in data and data['hora']:\n                # Asegurarse de que la hora tiene el formato correcto (HH:MM:SS)\n                # Si no sigue el formato, se deja como está\n                if isinstance(data['hora'], str) and len(data['hora']) == 8 and data['hora'][2] == ':' and data['hora'][5] == ':':\n                    # Prefijo con comilla simple para forzar formato de texto\n                    data['hora'] = f\"'{data['hora']}'\"\n                    logger.info(f\"Hora formateada como texto: {data['hora']}\")\n        \n        # Construir la fila de datos ordenada según las cabeceras\n        for header in headers:\n            row_data.append(data.get(header, \"\"))\n        \n        logger.info(f\"Añadiendo datos a '{sheet_name}': {data}\")\n        logger.info(f\"Datos formateados para Sheets: {row_data}\")\n        \n        # ENFOQUE COMPLETAMENTE NUEVO\n        try:\n            # 1. Primero obtenemos el ID de la hoja\n            sheet_metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n            sheets = sheet_metadata.get('sheets', '')\n            sheet_id = None\n            for sheet in sheets:\n                if sheet['properties']['title'] == sheet_name:\n                    sheet_id = sheet['properties']['sheetId']\n                    break\n            \n            if sheet_id is None:\n                logger.error(f\"No se pudo encontrar el ID de la hoja '{sheet_name}'\")\n                return False\n            \n            logger.info(f\"Usando sheet_id: {sheet_id} para '{sheet_name}'\")\n            \n            # 2. Usamos appendCells directamente en el API en lugar del helper append()\n            # Este enfoque evita completamente el problema de 'Resource' object has no attribute 'values'\n            request_body = {\n                \"requests\": [\n                    {\n                        \"appendCells\": {\n                            \"sheetId\": sheet_id,\n                            \"rows\": [\n                                {\n                                    \"values\": [\n                                        {\"userEnteredValue\": {\"stringValue\": str(value) if value is not None else \"\"}} \n                                        for value in row_data\n                                    ]\n                                }\n                            ],\n                            \"fields\": \"userEnteredValue\"\n                        }\n                    }\n                ]\n            }\n            \n            # Ejecutar el batchUpdate con la solicitud de appendCells\n            response = service.spreadsheets().batchUpdate(\n                spreadsheetId=spreadsheet_id,\n                body=request_body\n            ).execute()\n            \n            logger.info(f\"Datos añadidos correctamente a '{sheet_name}' usando appendCells\")\n            \n            # Si se agregó exitosamente una compra, actualizar también el almacén\n            if sheet_name == 'compras' and 'tipo_cafe' in data and 'kg_disponibles' in data:\n                try:\n                    # Extraer fase y cantidad de la compra\n                    fase = data['tipo_cafe']\n                    cantidad = float(data['kg_disponibles'])\n                    \n                    # Actualizar el almacén de forma asíncrona para no bloquear el proceso\n                    logger.info(f\"Actualizando almacén para compra de {cantidad} kg de {fase}\")\n                    \n                    # Intentar actualizar el almacén con la nueva cantidad\n                    # Esta llamada no la haremos asíncrona, pero podríamos considerar hacerlo en un futuro\n                    update_result = update_almacen(\n                        fase=fase,\n                        cantidad_cambio=cantidad,\n                        operacion=\"sumar\",\n                        notas=f\"Compra ID: {data.get('id', 'sin ID')}\",\n                        compra_id=data.get('id', '')\n                    )\n                    \n                    if update_result:\n                        logger.info(f\"Almacén actualizado correctamente para {fase}: +{cantidad} kg\")\n                    else:\n                        logger.warning(f\"No se pudo actualizar el almacén para {fase}: +{cantidad} kg\")\n                except Exception as e:\n                    logger.error(f\"Error al actualizar almacén después de compra: {e}\")\n                    # No fallar si hay un error en el almacén, solo registrar\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error al usar appendCells: {e}\")\n            \n            # Si falla el método principal, intentar un método de respaldo\n            try:\n                logger.info(\"Intentando método de respaldo con batchUpdate...\")\n                \n                # Obtener todas las filas para determinar el índice de la próxima fila\n                response = service.spreadsheets().values().get(\n                    spreadsheetId=spreadsheet_id,\n                    range=f\"{sheet_name}!A:A\"\n                ).execute()\n                \n                # Determinar la próxima fila (la cantidad de filas actuales + 1)\n                next_row = len(response.get('values', [])) + 1\n                logger.info(f\"Siguiente fila disponible: {next_row}\")\n                \n                # Actualizar esa fila específica\n                update_response = service.spreadsheets().values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=f\"{sheet_name}!A{next_row}:Z{next_row}\",\n                    valueInputOption=\"USER_ENTERED\",\n                    body={\"values\": [row_data]}\n                ).execute()\n                \n                logger.info(f\"Datos añadidos correctamente a '{sheet_name}' en la fila {next_row} usando método de respaldo\")\n                return True\n            except Exception as backup_error:\n                logger.error(f\"Error con método de respaldo: {backup_error}\")\n                \n                # Último intento: crear fila por fila manualmente (enfoque extremadamente básico)\n                try:\n                    logger.info(\"Intentando método de último recurso...\")\n                    \n                    # Construir una solicitud sin usar métodos auxiliares\n                    from googleapiclient.http import build_http\n                    \n                    # Crear el objeto Http\n                    http = build_http()\n                    \n                    # URL para el API de Sheets\n                    url = f\"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id}/values/{sheet_name}!A:A:append?valueInputOption=USER_ENTERED&insertDataOption=INSERT_ROWS\"\n                    \n                    # Datos a enviar\n                    data = {\n                        \"values\": [row_data]\n                    }\n                    \n                    # Headers con token de autorización\n                    headers = {\n                        \"Authorization\": f\"Bearer {service._http.credentials.token}\",\n                        \"Content-Type\": \"application/json\"\n                    }\n                    \n                    # Realizar la solicitud POST\n                    import requests\n                    response = requests.post(url, json=data, headers=headers)\n                    \n                    if response.status_code == 200:\n                        logger.info(f\"Datos añadidos correctamente a '{sheet_name}' usando método de último recurso\")\n                        return True\n                    else:\n                        logger.error(f\"Error con método de último recurso: {response.text}\")\n                        return False\n                except Exception as final_error:\n                    logger.error(f\"Error con método de último recurso: {final_error}\")\n                    return False\n    except Exception as e:\n        logger.error(f\"Error global al añadir datos a {sheet_name}: {e}\")\n        return False\n\ndef update_cell(sheet_name, row_index, column_name, value):\n    \"\"\"Actualiza una celda específica en la hoja de cálculo.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        row_index: Índice de la fila (basado en 0 para las filas de datos, excluyendo las cabeceras)\n        column_name: Nombre de la columna\n        value: Nuevo valor para la celda\n    \n    Returns:\n        bool: True si se actualizó correctamente, False en caso contrario\n    \"\"\"\n    if sheet_name not in HEADERS:\n        logger.error(f\"Nombre de hoja inválido: {sheet_name}\")\n        raise ValueError(f\"Nombre de hoja inválido: {sheet_name}\")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        service = get_sheet_service()\n        \n        # Obtener índice de la columna\n        headers = HEADERS[sheet_name]\n        if column_name not in headers:\n            logger.error(f\"Nombre de columna inválido: {column_name}\")\n            raise ValueError(f\"Nombre de columna inválido: {column_name}\")\n        \n        column_index = headers.index(column_name)\n        \n        # Convertir índice de fila (desde 0) a número de fila real en la hoja (desde 1, contando cabeceras)\n        # Fila 1 son las cabeceras, los datos comienzan en la fila 2\n        real_row = row_index + 2\n        \n        # Convertir índice de columna a letra de columna de Excel (A, B, C, ...)\n        column_letter = chr(65 + column_index)  # 65 es el código ASCII para 'A'\n        cell_reference = f\"{column_letter}{real_row}\"\n        \n        # Pre-procesamiento para campos específicos\n        if (sheet_name == 'adelantos' and column_name == 'fecha') or column_name == 'fecha':\n            value = format_date_for_sheets(value)\n        \n        logger.info(f\"Actualizando celda {cell_reference} en hoja '{sheet_name}' con valor: {value}\")\n        \n        # ENFOQUE MÁS ROBUSTO: Usar batchUpdate con updateCells\n        try:\n            # 1. Obtener el ID de la hoja\n            sheet_metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n            sheets = sheet_metadata.get('sheets', '')\n            sheet_id = None\n            for sheet in sheets:\n                if sheet['properties']['title'] == sheet_name:\n                    sheet_id = sheet['properties']['sheetId']\n                    break\n            \n            if sheet_id is None:\n                logger.error(f\"No se pudo encontrar el ID de la hoja '{sheet_name}'\")\n                return False\n            \n            # 2. Crear la solicitud de actualización usando updateCells\n            request_body = {\n                \"requests\": [\n                    {\n                        \"updateCells\": {\n                            \"range\": {\n                                \"sheetId\": sheet_id,\n                                \"startRowIndex\": real_row - 1,  # Índice basado en 0\n                                \"endRowIndex\": real_row,\n                                \"startColumnIndex\": column_index,\n                                \"endColumnIndex\": column_index + 1\n                            },\n                            \"rows\": [\n                                {\n                                    \"values\": [\n                                        {\n                                            \"userEnteredValue\": {\n                                                \"stringValue\": str(value) if value is not None else \"\"\n                                            }\n                                        }\n                                    ]\n                                }\n                            ],\n                            \"fields\": \"userEnteredValue\"\n                        }\n                    }\n                ]\n            }\n            \n            # 3. Ejecutar la solicitud\n            response = service.spreadsheets().batchUpdate(\n                spreadsheetId=spreadsheet_id,\n                body=request_body\n            ).execute()\n            \n            logger.info(f\"Celda actualizada correctamente con batchUpdate: {sheet_name}!{cell_reference}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error al actualizar celda con batchUpdate: {e}\")\n            \n            # Método alternativo de respaldo\n            try:\n                logger.info(\"Intentando método alternativo para actualizar celda...\")\n                \n                # Usar el método tradicional values().update()\n                service.spreadsheets().values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=f\"{sheet_name}!{cell_reference}\",\n                    valueInputOption=\"USER_ENTERED\",\n                    body={\"values\": [[value]]}\n                ).execute()\n                \n                logger.info(f\"Celda actualizada correctamente con método alternativo: {sheet_name}!{cell_reference}\")\n                return True\n            except Exception as backup_error:\n                logger.error(f\"Error con método alternativo para actualizar celda: {backup_error}\")\n                return False\n    except Exception as e:\n        logger.error(f\"Error global al actualizar celda: {e}\")\n        return False\n\ndef get_all_data(sheet_name):\n    \"\"\"Obtiene todos los datos de la hoja especificada\"\"\"\n    if sheet_name not in HEADERS:\n        logger.error(f\"Nombre de hoja inválido: {sheet_name}\")\n        raise ValueError(f\"Nombre de hoja inválido: {sheet_name}\")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        sheets = get_sheet_service()\n        \n        range_name = f\"{sheet_name}!A:Z\"\n        result = sheets.values().get(\n            spreadsheetId=spreadsheet_id,\n            range=range_name\n        ).execute()\n        \n        values = result.get('values', [])\n        \n        if not values:\n            logger.info(f\"No hay datos en la hoja '{sheet_name}'\")\n            return []\n        \n        # Convertir filas a diccionarios usando las cabeceras\n        headers = values[0]\n        rows = []\n        \n        for i, row in enumerate(values[1:]):  # Saltar la fila de cabeceras\n            # Asegurarse de que la fila tenga la misma longitud que las cabeceras\n            row_padded = row + [\"\"] * (len(headers) - len(row))\n            # Añadir el _row_index para referencia futura (basado en 0)\n            row_dict = dict(zip(headers, row_padded))\n            row_dict['_row_index'] = i\n            rows.append(row_dict)\n        \n        logger.info(f\"Obtenidos {len(rows)} registros de '{sheet_name}'\")\n        return rows\n    except Exception as e:\n        logger.error(f\"Error al obtener datos de {sheet_name}: {e}\")\n        return []\n\ndef get_filtered_data(sheet_name, filters=None, days=None):\n    \"\"\"\n    Obtiene datos filtrados de la hoja especificada\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        filters: Diccionario de filtros campo:valor\n        days: Si se proporciona, filtra por entradas en los últimos X días\n    \"\"\"\n    all_data = get_all_data(sheet_name)\n    \n    if not all_data:\n        return []\n    \n    filtered_data = all_data\n    \n    # Aplicar filtros\n    if filters:\n        # Para cada clave:valor de filtro, verificar coincidencia\n        filtered_data = []\n        for row in all_data:\n            match = True\n            for key, value in filters.items():\n                # Normalizar valores para comparación (convertir a mayúsculas y eliminar espacios adicionales)\n                row_value = str(row.get(key, '')).strip().upper()\n                filter_value = str(value).strip().upper()\n                \n                if row_value != filter_value:\n                    match = False\n                    break\n            \n            if match:\n                filtered_data.append(row)\n    \n    # Aplicar filtro de fecha (para futura implementación)\n    if days:\n        # TODO: Implementar filtrado por fecha\n        pass\n    \n    logger.info(f\"Filtrado: de {len(all_data)} registros a {len(filtered_data)} registros\")\n    return filtered_data\n\ndef es_transicion_valida(origen, destino):\n    \"\"\"Verifica si la transición de fase es válida\n    \n    Args:\n        origen: Fase de origen\n        destino: Fase de destino\n        \n    Returns:\n        bool: True si la transición es válida, False en caso contrario\n    \"\"\"\n    if origen not in TRANSICIONES_PERMITIDAS:\n        return False\n    \n    return destino in TRANSICIONES_PERMITIDAS[origen]\n\ndef get_compras_por_fase(fase):\n    \"\"\"\n    Obtiene todas las compras en una fase específica con kg disponibles\n    \n    Args:\n        fase: Fase actual del café (CEREZO, MOTE, PERGAMINO, etc.)\n        \n    Returns:\n        Lista de compras en la fase especificada que aún tienen kg disponibles\n    \"\"\"\n    try:\n        logger.info(f\"Buscando compras en fase: {fase}\")\n        # Obtener todas las compras\n        all_compras = get_all_data('compras')\n        \n        # Filtrar manualmente para evitar problemas de formato\n        compras_disponibles = []\n        for compra in all_compras:\n            # Normalizar fase para comparación\n            fase_actual = str(compra.get('fase_actual', '')).strip().upper()\n            fase_buscada = str(fase).strip().upper()\n            \n            # Verificar si hay coincidencia de fase\n            if fase_actual == fase_buscada:\n                try:\n                    # Verificar kg disponibles\n                    kg_disponibles = float(str(compra.get('kg_disponibles', '0')).replace(',', '.'))\n                    if kg_disponibles > 0:\n                        # Agregar a la lista de compras disponibles\n                        logger.info(f\"Compra encontrada: {compra.get('proveedor')} - {kg_disponibles} kg - ID: {compra.get('id')}\")\n                        compras_disponibles.append(compra)\n                except (ValueError, TypeError) as e:\n                    logger.warning(f\"Error al convertir kg_disponibles: {e}. Valor: {compra.get('kg_disponibles')}\")\n                    continue\n        \n        logger.info(f\"Total compras encontradas en fase {fase}: {len(compras_disponibles)}\")\n        return compras_disponibles\n    except Exception as e:\n        logger.error(f\"Error al obtener compras en fase {fase}: {e}\")\n        return []\n\ndef get_almacen_cantidad(fase):\n    \"\"\"\n    Obtiene la cantidad disponible de una fase específica del almacén\n    \n    Args:\n        fase: Fase del café (CEREZO, MOTE, PERGAMINO, etc.)\n    \n    Returns:\n        float: Cantidad disponible en kg\n    \"\"\"\n    try:\n        # Normalizar fase para búsqueda\n        fase_buscada = fase.strip().upper()\n        \n        # Obtener datos de almacén filtrados por fase_actual\n        almacen_data = get_filtered_data('almacen', {'fase_actual': fase_buscada})\n        \n        if not almacen_data:\n            logger.warning(f\"No se encontró la fase {fase_buscada} en el almacén\")\n            return 0.0\n        \n        # Calcular la suma total de todas las entradas con esa fase actual\n        total_cantidad = 0.0\n        for registro in almacen_data:\n            try:\n                cantidad = float(str(registro.get('cantidad', '0')).replace(',', '.'))\n                total_cantidad += cantidad\n            except (ValueError, TypeError) as e:\n                logger.error(f\"Error al convertir cantidad en almacén: {e}\")\n        \n        logger.info(f\"Cantidad total en almacén para fase {fase_buscada}: {total_cantidad} kg\")\n        return total_cantidad\n    except Exception as e:\n        logger.error(f\"Error al obtener cantidad en almacén para fase {fase}: {e}\")\n        return 0.0\n\ndef update_almacen(fase, cantidad_cambio, operacion=\"sumar\", notas=\"\", compra_id=\"\"):\n    \"\"\"\n    Actualiza la cantidad disponible en el almacén para una fase específica\n    \n    Args:\n        fase: Fase del café (CEREZO, MOTE, PERGAMINO, etc.)\n        cantidad_cambio: Cantidad a sumar o restar\n        operacion: \"sumar\" para añadir, \"restar\" para disminuir, \"establecer\" para fijar valor\n        notas: Notas adicionales sobre la operación\n        compra_id: ID de compra relacionada (si aplica)\n    \n    Returns:\n        bool: True si se actualizó correctamente, False en caso contrario\n    \"\"\"\n    try:\n        import datetime\n        \n        logger.info(f\"Actualizando almacén - Fase: {fase}, Cambio: {cantidad_cambio} kg, Operación: {operacion}, Compra ID: {compra_id}\")\n        \n        # Normalizar fase\n        fase_normalizada = fase.strip().upper()\n        \n        # Crear nuevo registro para esta operación de almacén\n        now = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        nueva_entrada = {\n            \"id\": generate_almacen_id(),\n            \"compra_id\": compra_id,\n            \"fase\": fase_normalizada,\n            \"fecha\": now,\n            \"cantidad\": cantidad_cambio if operacion in [\"sumar\", \"establecer\"] else -cantidad_cambio,\n            \"fase_actual\": fase_normalizada,\n            \"notas\": f\"Operación: {operacion}. {notas}\"\n        }\n        \n        # Añadir a la hoja\n        resultado = append_data(\"almacen\", nueva_entrada)\n        \n        if resultado:\n            logger.info(f\"Nuevo registro de almacén creado correctamente: {nueva_entrada['id']}\")\n            return True\n        else:\n            logger.error(f\"Error al crear nuevo registro de almacén\")\n            return False\n    except Exception as e:\n        logger.error(f\"Error al actualizar almacén: {e}\")\n        return False\n\ndef actualizar_almacen_desde_proceso(origen, destino, cantidad, merma):\n    \"\"\"\n    Actualiza el almacén basado en un proceso de transformación\n    \n    Args:\n        origen: Fase de origen del café\n        destino: Fase de destino del café\n        cantidad: Cantidad procesada en kg\n        merma: Cantidad de merma en kg\n    \n    Returns:\n        bool: True si se actualizó correctamente, False en caso contrario\n    \"\"\"\n    try:\n        logger.info(f\"Actualizando almacén desde proceso - Origen: {origen}, Destino: {destino}, Cantidad: {cantidad} kg, Merma: {merma} kg\")\n        \n        # 1. Restar la cantidad procesada de la fase de origen\n        resultado_origen = update_almacen(\n            fase=origen,\n            cantidad_cambio=cantidad,\n            operacion=\"restar\",\n            notas=f\"Proceso a {destino}\"\n        )\n        \n        # 2. Calcular cantidad resultante (restando merma)\n        cantidad_resultante = max(0, float(cantidad) - float(merma))\n        \n        # 3. Sumar la cantidad resultante a la fase de destino\n        resultado_destino = update_almacen(\n            fase=destino,\n            cantidad_cambio=cantidad_resultante,\n            operacion=\"sumar\",\n            notas=f\"Procesado desde {origen}\"\n        )\n        \n        return resultado_origen and resultado_destino\n    except Exception as e:\n        logger.error(f\"Error al actualizar almacén desde proceso: {e}\")\n        return False\n\ndef sincronizar_almacen_con_compras():\n    \"\"\"\n    Sincroniza el almacén con las existencias actuales en las compras.\n    Útil para inicializar o corregir discrepancias.\n    \n    Returns:\n        bool: True si se sincronizó correctamente, False en caso contrario\n    \"\"\"\n    try:\n        logger.info(\"Iniciando sincronización de almacén con compras\")\n        \n        # Para cada fase, calcular la suma total de kg disponibles\n        totales_por_fase = {}\n        for fase in FASES_CAFE:\n            compras = get_compras_por_fase(fase)\n            total_kg = sum(float(str(compra.get('kg_disponibles', '0')).replace(',', '.')) for compra in compras)\n            totales_por_fase[fase] = round(total_kg, 2)\n            logger.info(f\"Fase {fase}: {total_kg} kg disponibles en compras\")\n        \n        # Actualizar cada fase en el almacén\n        import datetime\n        now = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        resultados = []\n        for fase, total in totales_por_fase.items():\n            resultado = update_almacen(\n                fase=fase,\n                cantidad_cambio=total,\n                operacion=\"establecer\",\n                notas=f\"Sincronización automática con compras ({now})\"\n            )\n            resultados.append(resultado)\n        \n        # Verificar que todas las actualizaciones fueron exitosas\n        if all(resultados):\n            logger.info(\"Sincronización de almacén completada correctamente\")\n            return True\n        else:\n            logger.error(f\"Error al sincronizar almacén: {resultados.count(False)}/{len(resultados)} operaciones fallaron\")\n            return False\n    except Exception as e:\n        logger.error(f\"Error al sincronizar almacén con compras: {e}\")\n        return False\n\ndef leer_almacen_para_proceso():\n    \"\"\"\n    Lee los registros de almacén para mostrarlos en el comando /proceso\n    \n    Returns:\n        list: Lista de registros de almacén con información relevante\n    \"\"\"\n    try:\n        logger.info(\"Leyendo registros de almacén para proceso\")\n        \n        # Obtener todos los registros de almacén\n        almacen_data = get_all_data('almacen')\n        \n        # Agrupar y sumar por fase_actual\n        resultados = {}\n        for registro in almacen_data:\n            fase_actual = str(registro.get('fase_actual', '')).strip().upper()\n            if fase_actual in FASES_CAFE:\n                # Sumar las cantidades por fase\n                try:\n                    cantidad = float(str(registro.get('cantidad', '0')).replace(',', '.'))\n                    if fase_actual not in resultados:\n                        resultados[fase_actual] = {\n                            'cantidad_total': 0,\n                            'registros': []\n                        }\n                    \n                    resultados[fase_actual]['cantidad_total'] += cantidad\n                    resultados[fase_actual]['registros'].append(registro)\n                except (ValueError, TypeError) as e:\n                    logger.error(f\"Error al procesar cantidad en almacén: {e}\")\n        \n        return resultados\n    except Exception as e:\n        logger.error(f\"Error al leer almacén para proceso: {e}\")\n        return {}