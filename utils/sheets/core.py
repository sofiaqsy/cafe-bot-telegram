"""\nMódulo con las operaciones básicas para Google Sheets.\n"""\nimport logging\nfrom typing import Dict, List, Any, Optional, Union\nimport requests\n\nfrom utils.sheets.constants import HEADERS\nfrom utils.sheets.service import get_sheet_service, get_or_create_sheet, get_sheet_id, get_sheets_initialized, set_sheets_initialized\nfrom utils.sheets.utils import format_date_for_sheets, generate_unique_id, generate_almacen_id, get_current_datetime_str, safe_float\n\n# Configurar logging\nlogger = logging.getLogger(__name__)\n\ndef initialize_sheets():\n    """\n    Inicializa las hojas de Google Sheets con las cabeceras correctas.\n    \n    Returns:\n        bool: True si se inicializaron correctamente, False en caso contrario\n    """\n    # Si ya se inicializaron las hojas en esta sesión, no volver a hacerlo\n    if get_sheets_initialized():\n        logger.info("Las hojas ya fueron inicializadas en esta sesión, omitiendo...")\n        return True\n    \n    try:\n        sheets = get_sheet_service()\n        spreadsheet_id = get_or_create_sheet()\n        \n        # Obtener todas las hojas existentes\n        sheet_metadata = sheets.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n        existing_sheets = {sheet['properties']['title'] for sheet in sheet_metadata.get('sheets', [])}\n        \n        # Para cada hoja definida en HEADERS\n        for sheet_name, headers in HEADERS.items():\n            # Verificar si la hoja existe\n            if sheet_name not in existing_sheets:\n                # Crear la hoja\n                logger.info(f"Creando hoja '{sheet_name}'...")\n                requests = [{\n                    'addSheet': {\n                        'properties': {\n                            'title': sheet_name\n                        }\n                    }\n                }]\n                sheets.spreadsheets().batchUpdate(\n                    spreadsheetId=spreadsheet_id,\n                    body={'requests': requests}\n                ).execute()\n                \n                # Verificar si la hoja se creó correctamente\n                sheet_metadata = sheets.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n                updated_existing_sheets = {sheet['properties']['title'] for sheet in sheet_metadata.get('sheets', [])}\n                \n                if sheet_name in updated_existing_sheets:\n                    logger.info(f"Hoja '{sheet_name}' creada correctamente")\n                else:\n                    logger.error(f"Error al crear la hoja '{sheet_name}'")\n                    continue\n            \n            # Verificar si la hoja tiene cabeceras\n            range_name = f"{sheet_name}!A1:Z1"\n            result = sheets.spreadsheets().values().get(\n                spreadsheetId=spreadsheet_id,\n                range=range_name\n            ).execute()\n            \n            values = result.get('values', [])\n            \n            if not values or len(values[0]) < len(headers):\n                # Escribir las cabeceras\n                logger.info(f"Escribiendo cabeceras para la hoja '{sheet_name}'...")\n                sheets.spreadsheets().values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=range_name,\n                    valueInputOption="RAW",\n                    body={"values": [headers]}\n                ).execute()\n                \n                logger.info(f"Cabeceras para '{sheet_name}' actualizadas correctamente")\n            else:\n                logger.info(f"La hoja '{sheet_name}' ya tiene cabeceras")\n            \n            # Operaciones especiales por tipo de hoja\n            if sheet_name == 'compras':\n                # Para compras existentes, asegurarse de que tengan un ID único\n                # Esto es para mantener compatibilidad con compras que no tenían ID\n                compras = get_all_data('compras')\n                for i, compra in enumerate(compras):\n                    if not compra.get('id'):\n                        # Generar un ID único\n                        nuevo_id = generate_unique_id()\n                        # Actualizar la compra\n                        update_cell('compras', compra['_row_index'], 'id', nuevo_id)\n                        logger.info(f"Asignado ID {nuevo_id} a compra existente (fila {compra['_row_index'] + 2})")\n                    \n                    # Migrar datos antiguos al nuevo formato: fase_actual y kg_disponibles van a almacen\n                    if ('fase_actual' in compra or 'kg_disponibles' in compra) and compra.get('tipo_cafe'):\n                        fase = compra.get('fase_actual', compra.get('tipo_cafe'))\n                        kg_disponibles = safe_float(compra.get('kg_disponibles', compra.get('cantidad', 0)))\n                        \n                        # Verificar si ya existe un registro en almacén para esta compra\n                        compra_id = compra.get('id', '')\n                        almacen_existente = []\n                        if compra_id:\n                            almacen_existente = get_filtered_data('almacen', {'compra_id': compra_id})\n                        \n                        # Solo crear registro si no existe y si hay kg disponibles\n                        if not almacen_existente and kg_disponibles > 0:\n                            now = get_current_datetime_str()\n                            append_data('almacen', {\n                                'id': generate_almacen_id(),\n                                'compra_id': compra_id,\n                                'tipo_cafe_origen': fase,\n                                'fecha': now,\n                                'cantidad': compra.get('cantidad', 0),\n                                'fase_actual': fase,\n                                'cantidad_actual': kg_disponibles,\n                                'notas': f"Migración automática desde compra ID: {compra_id}",\n                                'fecha_actualizacion': now\n                            })\n                            logger.info(f"Creado registro en almacén para compra {compra_id} con {kg_disponibles} kg en fase {fase}")\n        \n        # Marcar hojas como inicializadas para esta sesión\n        set_sheets_initialized(True)\n        \n        logger.info("Inicialización de hojas completada correctamente")\n        return True\n    except Exception as e:\n        logger.error(f"Error al inicializar las hojas: {e}")\n        return False\n\ndef append_data(sheet_name, data):\n    """\n    Añade una fila de datos a la hoja especificada.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        data: Diccionario con los datos a añadir\n        \n    Returns:\n        bool: True si se añadieron los datos correctamente, False en caso contrario\n    """\n    if sheet_name not in HEADERS:\n        logger.error(f"Nombre de hoja inválido: {sheet_name}")\n        raise ValueError(f"Nombre de hoja inválido: {sheet_name}")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        service = get_sheet_service()\n        \n        # Para compras, asegurar que tenga un ID único\n        if sheet_name == 'compras':\n            # Siempre asignar un ID único, incluso si ya existe uno\n            if not data.get('id'):\n                data['id'] = generate_unique_id()\n                logger.info(f"Generado ID único para compra: {data['id']}")\n            \n            # Calcular precio total si no está especificado o es 0\n            if ('preciototal' not in data or not data.get('preciototal') or safe_float(data.get('preciototal')) == 0) and 'cantidad' in data and 'precio' in data:\n                try:\n                    cantidad = float(str(data.get('cantidad', '0')).replace(',', '.'))\n                    precio = float(str(data.get('precio', '0')).replace(',', '.'))\n                    # Asegurar que el precio no sea 0\n                    if precio <= 0:\n                        logger.warning(f"Precio está configurado a {precio}, podría ser un error. Se guardará como está.")\n                    data['preciototal'] = str(round(cantidad * precio, 2))\n                    logger.info(f"Calculado precio total para compra: {data['preciototal']}")\n                except (ValueError, TypeError) as e:\n                    logger.warning(f"Error al calcular precio total: {e}")\n        \n        # Para almacén, asegurar que tenga un ID único\n        if sheet_name == 'almacen' and 'id' not in data:\n            data['id'] = generate_almacen_id()\n            logger.info(f"Generado ID único para almacén: {data['id']}")\n            \n            # Si no tiene fecha, agregar la fecha actual\n            if 'fecha' not in data or not data['fecha']:\n                data['fecha'] = get_current_datetime_str()\n            \n            # Agregar fecha de actualización si no existe\n            if 'fecha_actualizacion' not in data or not data['fecha_actualizacion']:\n                data['fecha_actualizacion'] = get_current_datetime_str()\n                logger.info(f"Añadida fecha de actualización: {data['fecha_actualizacion']}")\n        \n        # Convertir el diccionario a una lista ordenada según las cabeceras\n        headers = HEADERS[sheet_name]\n        row_data = []\n        \n        # Imprimir información detallada para depurar\n        logger.info(f"Cabeceras para la hoja '{sheet_name}': {headers}")\n        logger.info(f"Datos recibidos: {data}")\n        \n        # Verificar que todos los campos necesarios existan\n        for header in headers:\n            if header not in data or not data[header]:\n                logger.warning(f"Campo '{header}' faltante o vacío en los datos. Usando valor por defecto.")\n                \n                # Valores por defecto según el campo\n                if header == 'tipo_cafe' or header == 'tipo_cafe_origen':\n                    data[header] = "No especificado"\n                elif header in ['cantidad', 'precio', 'total', 'cantidad_actual', 'merma', 'merma_estimada', 'cantidad_resultante', 'cantidad_resultante_esperada', 'preciototal']:\n                    data[header] = "0"\n                elif header == 'fase_actual' and sheet_name == 'almacen' and 'tipo_cafe_origen' in data:\n                    # Si es almacén, la fase_actual es la misma que la fase\n                    data[header] = data.get('tipo_cafe_origen', "")\n                elif header == 'fecha_actualizacion' and sheet_name == 'almacen':\n                    # Fecha de actualización para registros de almacén\n                    data[header] = get_current_datetime_str()\n                else:\n                    data[header] = ""\n        \n        # Pre-procesamiento específico para el campo de fecha\n        # Para adelantos, asegurarnos de que las fechas tengan el formato correcto\n        if sheet_name == 'adelantos':\n            # Formatear explícitamente la fecha como texto para evitar que Sheets la convierta en número\n            if 'fecha' in data and data['fecha']:\n                data['fecha'] = format_date_for_sheets(data['fecha'])\n            \n            # Hacer lo mismo con la hora\n            if 'hora' in data and data['hora']:\n                # Asegurarse de que la hora tiene el formato correcto (HH:MM:SS)\n                # Si no sigue el formato, se deja como está\n                if isinstance(data['hora'], str) and len(data['hora']) == 8 and data['hora'][2] == ':' and data['hora'][5] == ':':\n                    # Prefijo con comilla simple para forzar formato de texto\n                    data['hora'] = f"'{data['hora']}'"\n                    logger.info(f"Hora formateada como texto: {data['hora']}")\n        \n        # Construir la fila de datos ordenada según las cabeceras\n        for header in headers:\n            row_data.append(data.get(header, ""))\n        \n        logger.info(f"Añadiendo datos a '{sheet_name}': {data}")\n        logger.info(f"Datos formateados para Sheets: {row_data}")\n        \n        # ENFOQUE USANDO APPENDCELLS (más robusto)\n        try:\n            # 1. Obtener el ID de la hoja\n            sheet_id = get_sheet_id(sheet_name)\n            \n            if sheet_id is None:\n                logger.error(f"No se pudo encontrar el ID de la hoja '{sheet_name}'")\n                return False\n            \n            logger.info(f"Usando sheet_id: {sheet_id} para '{sheet_name}'")\n            \n            # 2. Usamos appendCells directamente en el API\n            request_body = {\n                "requests": [\n                    {\n                        "appendCells": {\n                            "sheetId": sheet_id,\n                            "rows": [\n                                {\n                                    "values": [\n                                        {"userEnteredValue": {"stringValue": str(value) if value is not None else ""}} \n                                        for value in row_data\n                                    ]\n                                }\n                            ],\n                            "fields": "userEnteredValue"\n                        }\n                    }\n                ]\n            }\n            \n            # Ejecutar el batchUpdate con la solicitud de appendCells\n            response = service.spreadsheets().batchUpdate(\n                spreadsheetId=spreadsheet_id,\n                body=request_body\n            ).execute()\n            \n            logger.info(f"Datos añadidos correctamente a '{sheet_name}' usando appendCells")\n            \n            # Si se agregó exitosamente una compra, crear también el registro en almacén\n            # SOLO crear registro en almacén si es una compra nueva y no si ya estamos creando un registro de almacén\n            # para evitar duplicación\n            if sheet_name == 'compras' and 'tipo_cafe' in data and 'cantidad' in data:\n                try:\n                    # Extraer datos de la compra\n                    fase = data['tipo_cafe']\n                    cantidad = float(str(data.get('cantidad', '0')).replace(',', '.'))\n                    compra_id = data.get('id', '')\n                    \n                    # Verificar si ya existe un registro en almacén para esta compra\n                    almacen_existente = []\n                    if compra_id:\n                        almacen_existente = get_filtered_data('almacen', {'compra_id': compra_id})\n                    \n                    # SOLO crear registro si no existe y si hay kg disponibles\n                    if not almacen_existente and cantidad > 0:\n                        # Crear registro en almacén para esta compra\n                        now = get_current_datetime_str()\n                        \n                        # Registro de almacén para la nueva compra\n                        nuevo_almacen = {\n                            'id': generate_almacen_id(),\n                            'compra_id': data.get('id', ''),\n                            'tipo_cafe_origen': fase,\n                            'fecha': now,\n                            'cantidad': cantidad,\n                            'fase_actual': fase,\n                            'cantidad_actual': cantidad,\n                            'notas': f"Compra inicial ID: {data.get('id', 'sin ID')}",\n                            'fecha_actualizacion': now\n                        }\n                        \n                        # Añadir a la hoja de almacén\n                        result_almacen = append_data('almacen', nuevo_almacen)\n                        \n                        if result_almacen:\n                            logger.info(f"Registro de almacén creado para compra {data.get('id')}: {cantidad} kg de {fase}")\n                        else:\n                            logger.warning(f"No se pudo crear registro en almacén para compra {data.get('id')}")\n                    else:\n                        if almacen_existente:\n                            logger.info(f"Ya existe un registro en almacén para la compra {compra_id}, no se creará otro")\n                    \n                except Exception as e:\n                    logger.error(f"Error al crear registro en almacén después de compra: {e}")\n                    # No fallar si hay un error en el almacén, solo registrar\n            \n            return True\n        except Exception as e:\n            logger.error(f"Error al usar appendCells: {e}")\n            \n            # Si falla el método principal, intentar un método de respaldo\n            try:\n                logger.info("Intentando método de respaldo con batchUpdate...")\n                \n                # Obtener todas las filas para determinar el índice de la próxima fila\n                response = service.spreadsheets().values().get(\n                    spreadsheetId=spreadsheet_id,\n                    range=f"{sheet_name}!A:A"\n                ).execute()\n                \n                # Determinar la próxima fila (la cantidad de filas actuales + 1)\n                next_row = len(response.get('values', [])) + 1\n                logger.info(f"Siguiente fila disponible: {next_row}")\n                \n                # Actualizar esa fila específica\n                update_response = service.spreadsheets().values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=f"{sheet_name}!A{next_row}:Z{next_row}",\n                    valueInputOption="USER_ENTERED",\n                    body={"values": [row_data]}\n                ).execute()\n                \n                logger.info(f"Datos añadidos correctamente a '{sheet_name}' en la fila {next_row} usando método de respaldo")\n                return True\n            except Exception as backup_error:\n                logger.error(f"Error con método de respaldo: {backup_error}")\n                \n                # Último intento: crear fila por fila manualmente (enfoque extremadamente básico)\n                try:\n                    logger.info("Intentando método de último recurso...")\n                    \n                    # URL para el API de Sheets\n                    url = f"https://sheets.googleapis.com/v4/spreadsheets/{spreadsheet_id}/values/{sheet_name}!A:A:append?valueInputOption=USER_ENTERED&insertDataOption=INSERT_ROWS"\n                    \n                    # Datos a enviar\n                    data_to_send = {\n                        "values": [row_data]\n                    }\n                    \n                    # Headers con token de autorización\n                    headers = {\n                        "Authorization": f"Bearer {service._http.credentials.token}",\n                        "Content-Type": "application/json"\n                    }\n                    \n                    # Realizar la solicitud POST\n                    response = requests.post(url, json=data_to_send, headers=headers)\n                    \n                    if response.status_code == 200:\n                        logger.info(f"Datos añadidos correctamente a '{sheet_name}' usando método de último recurso")\n                        return True\n                    else:\n                        logger.error(f"Error con método de último recurso: {response.text}")\n                        return False\n                except Exception as final_error:\n                    logger.error(f"Error con método de último recurso: {final_error}")\n                    return False\n    except Exception as e:\n        logger.error(f"Error global al añadir datos a {sheet_name}: {e}")\n        return False\n\ndef update_cell(sheet_name, row_index, column_name, value):\n    """\n    Actualiza una celda específica en la hoja de cálculo.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        row_index: Índice de la fila (basado en 0 para las filas de datos, excluyendo las cabeceras)\n        column_name: Nombre de la columna\n        value: Nuevo valor para la celda\n    \n    Returns:\n        bool: True si se actualizó correctamente, False en caso contrario\n    """\n    if sheet_name not in HEADERS:\n        logger.error(f"Nombre de hoja inválido: {sheet_name}")\n        raise ValueError(f"Nombre de hoja inválido: {sheet_name}")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        service = get_sheet_service()\n        \n        # Obtener índice de la columna\n        headers = HEADERS[sheet_name]\n        if column_name not in headers:\n            logger.error(f"Nombre de columna inválido: {column_name}")\n            raise ValueError(f"Nombre de columna inválido: {column_name}")\n        \n        column_index = headers.index(column_name)\n        \n        # Convertir índice de fila (desde 0) a número de fila real en la hoja (desde 1, contando cabeceras)\n        # Fila 1 son las cabeceras, los datos comienzan en la fila 2\n        real_row = row_index + 2\n        \n        # Convertir índice de columna a letra de columna de Excel (A, B, C, ...)\n        column_letter = chr(65 + column_index)  # 65 es el código ASCII para 'A'\n        cell_reference = f"{column_letter}{real_row}"\n        \n        # Pre-procesamiento para campos específicos\n        if (sheet_name == 'adelantos' and column_name == 'fecha') or column_name == 'fecha':\n            value = format_date_for_sheets(value)\n        \n        logger.info(f"Actualizando celda {cell_reference} en hoja '{sheet_name}' con valor: {value}")\n        \n        # ENFOQUE MÁS ROBUSTO: Usar batchUpdate con updateCells\n        try:\n            # 1. Obtener el ID de la hoja\n            sheet_id = get_sheet_id(sheet_name)\n            \n            if sheet_id is None:\n                logger.error(f"No se pudo encontrar el ID de la hoja '{sheet_name}'")\n                return False\n            \n            # 2. Crear la solicitud de actualización usando updateCells\n            request_body = {\n                "requests": [\n                    {\n                        "updateCells": {\n                            "range": {\n                                "sheetId": sheet_id,\n                                "startRowIndex": real_row - 1,  # Índice basado en 0\n                                "endRowIndex": real_row,\n                                "startColumnIndex": column_index,\n                                "endColumnIndex": column_index + 1\n                            },\n                            "rows": [\n                                {\n                                    "values": [\n                                        {\n                                            "userEnteredValue": {\n                                                "stringValue": str(value) if value is not None else ""\n                                            }\n                                        }\n                                    ]\n                                }\n                            ],\n                            "fields": "userEnteredValue"\n                        }\n                    }\n                ]\n            }\n            \n            # 3. Ejecutar la solicitud\n            response = service.spreadsheets().batchUpdate(\n                spreadsheetId=spreadsheet_id,\n                body=request_body\n            ).execute()\n            \n            logger.info(f"Celda actualizada correctamente con batchUpdate: {sheet_name}!{cell_reference}")\n            return True\n        except Exception as e:\n            logger.error(f"Error al actualizar celda con batchUpdate: {e}")\n            \n            # Método alternativo de respaldo\n            try:\n                logger.info("Intentando método alternativo para actualizar celda...")\n                \n                # Usar el método tradicional values().update()\n                service.spreadsheets().values().update(\n                    spreadsheetId=spreadsheet_id,\n                    range=f"{sheet_name}!{cell_reference}",\n                    valueInputOption="USER_ENTERED",\n                    body={"values": [[value]]}\n                ).execute()\n                \n                logger.info(f"Celda actualizada correctamente con método alternativo: {sheet_name}!{cell_reference}")\n                return True\n            except Exception as backup_error:\n                logger.error(f"Error con método alternativo para actualizar celda: {backup_error}")\n                return False\n    except Exception as e:\n        logger.error(f"Error global al actualizar celda: {e}")\n        return False\n\ndef get_all_data(sheet_name):\n    """\n    Obtiene todos los datos de la hoja especificada.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        \n    Returns:\n        List[Dict]: Lista de diccionarios con los datos\n    """\n    if sheet_name not in HEADERS:\n        logger.error(f"Nombre de hoja inválido: {sheet_name}")\n        raise ValueError(f"Nombre de hoja inválido: {sheet_name}")\n    \n    try:\n        spreadsheet_id = get_or_create_sheet()\n        sheets = get_sheet_service()\n        \n        range_name = f"{sheet_name}!A:Z"\n        \n        # Usar la llamada directa a sheets.spreadsheets().values().get()\n        result = None\n        try:\n            result = sheets.spreadsheets().values().get(\n                spreadsheetId=spreadsheet_id,\n                range=range_name\n            ).execute()\n        except Exception as e:\n            logger.error(f"Error al ejecutar values().get() para {sheet_name}: {e}")\n            # Si hay un error específico con values(), intentar otra aproximación\n            return handle_values_attribute_error(sheet_name, spreadsheet_id, sheets)\n        \n        values = result.get('values', [])\n        \n        if not values:\n            logger.info(f"No hay datos en la hoja '{sheet_name}'")\n            return []\n        \n        # Convertir filas a diccionarios usando las cabeceras\n        headers = values[0]\n        rows = []\n        \n        for i, row in enumerate(values[1:]):  # Saltar la fila de cabeceras\n            # Asegurarse de que la fila tenga la misma longitud que las cabeceras\n            row_padded = row + [""] * (len(headers) - len(row))\n            # Añadir el _row_index para referencia futura (basado en 0)\n            row_dict = dict(zip(headers, row_padded))\n            row_dict['_row_index'] = i\n            rows.append(row_dict)\n        \n        logger.info(f"Obtenidos {len(rows)} registros de '{sheet_name}'")\n        return rows\n    except Exception as e:\n        logger.error(f"Error al obtener datos de {sheet_name}: {e}")\n        return []\n\ndef handle_values_attribute_error(sheet_name, spreadsheet_id, sheets_service):\n    """\n    Maneja el error 'Resource' object has no attribute 'values'.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        spreadsheet_id: ID del spreadsheet\n        sheets_service: Servicio de Google Sheets\n        \n    Returns:\n        List[Dict]: Lista de diccionarios con los datos\n    """\n    logger.info(f"Usando método alternativo para obtener datos de la hoja '{sheet_name}'")\n    \n    try:\n        # 1. Obtener metadatos de la hoja\n        sheet_metadata = sheets_service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\n        target_sheet = None\n        \n        # Buscar la hoja específica\n        for sheet in sheet_metadata.get('sheets', []):\n            if sheet['properties']['title'] == sheet_name:\n                target_sheet = sheet\n                break\n        \n        if not target_sheet:\n            logger.warning(f"No se encontró la hoja '{sheet_name}' en el spreadsheet")\n            return []\n        \n        # 2. Usar batchGet para obtener datos\n        # Este método es más robusto y evita usar directamente el atributo 'values'\n        result = sheets_service.spreadsheets().values().batchGet(\n            spreadsheetId=spreadsheet_id,\n            ranges=[f"{sheet_name}!A:Z"]\n        ).execute()\n        \n        # Extraer los valores del resultado\n        value_ranges = result.get('valueRanges', [])\n        if not value_ranges or 'values' not in value_ranges[0]:\n            logger.warning(f"No se encontraron datos en la hoja '{sheet_name}'")\n            return []\n        \n        values = value_ranges[0]['values']\n        \n        # Procesar los valores como antes\n        if not values:\n            logger.info(f"No hay datos en la hoja '{sheet_name}'")\n            return []\n        \n        # Convertir filas a diccionarios usando las cabeceras\n        headers = values[0]\n        rows = []\n        \n        for i, row in enumerate(values[1:]):  # Saltar la fila de cabeceras\n            # Asegurarse de que la fila tenga la misma longitud que las cabeceras\n            row_padded = row + [""] * (len(headers) - len(row))\n            # Añadir el _row_index para referencia futura (basado en 0)\n            row_dict = dict(zip(headers, row_padded))\n            row_dict['_row_index'] = i\n            rows.append(row_dict)\n        \n        logger.info(f"Obtenidos {len(rows)} registros de '{sheet_name}' usando método alternativo")\n        return rows\n        \n    except Exception as e:\n        logger.error(f"Error en método alternativo para obtener datos: {e}")\n        return []\n\ndef get_filtered_data(sheet_name, filters=None, days=None):\n    """\n    Obtiene datos filtrados de la hoja especificada.\n    \n    Args:\n        sheet_name: Nombre de la hoja\n        filters: Diccionario de filtros campo:valor\n        days: Si se proporciona, filtra por entradas en los últimos X días\n        \n    Returns:\n        List[Dict]: Lista de diccionarios con los datos filtrados\n    """\n    all_data = get_all_data(sheet_name)\n    \n    if not all_data:\n        return []\n    \n    filtered_data = all_data\n    \n    # Aplicar filtros\n    if filters:\n        # Para cada clave:valor de filtro, verificar coincidencia\n        filtered_data = []\n        for row in all_data:\n            match = True\n            for key, value in filters.items():\n                # Normalizar valores para comparación (convertir a mayúsculas y eliminar espacios adicionales)\n                row_value = str(row.get(key, '')).strip().upper()\n                filter_value = str(value).strip().upper()\n                \n                if row_value != filter_value:\n                    match = False\n                    break\n            \n            if match:\n                filtered_data.append(row)\n    \n    # Aplicar filtro de fecha (para futura implementación)\n    if days:\n        # TODO: Implementar filtrado por fecha\n        pass\n    \n    logger.info(f"Filtrado: de {len(all_data)} registros a {len(filtered_data)} registros")\n    return filtered_data