import logging\nimport traceback\nfrom datetime import datetime\nfrom telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import (\n    ContextTypes, CommandHandler, ConversationHandler, \n    MessageHandler, filters, CallbackQueryHandler\n)\n\nfrom utils.sheets import append_data as append_sheets, generate_unique_id, get_all_data, get_filtered_data\nfrom utils.helpers import get_now_peru, safe_float, format_date_for_sheets, format_currency, calculate_total\nfrom utils.formatters import formatear_numero, formatear_precio, procesar_entrada_numerica\nfrom utils.sheets.almacen import update_almacen\n\n# Configurar logging\nlogger = logging.getLogger(__name__)\n# Asegurar que los logs sean visibles\nlogger.setLevel(logging.DEBUG)\n\n# Estados para la conversaci√≥n\nTIPO_CAFE, PROVEEDOR, CANTIDAD, PRECIO, METODO_PAGO, MONTO_EFECTIVO, MONTO_TRANSFERENCIA, SELECCIONAR_ADELANTO, CONFIRMAR = range(9)\n\n# Tipos de caf√© predefinidos - solo 3 opciones fijas (copiado de compras.py)\nTIPOS_CAFE = [\"CEREZO\", \"MOTE\", \"PERGAMINO\"]\n\n# M√©todos de pago disponibles\nMETODOS_PAGO = [\n    \"EFECTIVO\", \n    \"TRANSFERENCIA\", \n    \"EFECTIVO Y TRANSFERENCIA\", \n    \"ADELANTO\", \n    \"EFECTIVO Y ADELANTO\", \n    \"TRANSFERENCIA Y ADELANTO\"\n]\n\n# Datos temporales\ndatos_compra_mixta = {}\n\n# Headers para la hoja de compras mixtas\nCOMPRAS_MIXTAS_HEADERS = [\n    \"id\", \"fecha\", \"tipo_cafe\", \"proveedor\", \"cantidad\", \"precio\", \"preciototal\", \n    \"metodo_pago\", \"monto_efectivo\", \"monto_transferencia\", \"monto_adelanto\", \n    \"adelanto_id\", \"registrado_por\", \"notas\"\n]\n\ndef debug_log(message):\n    \"\"\"Funci√≥n especial para logs de depuraci√≥n m√°s visibles\"\"\"\n    logger.debug(f\"### DEBUG ### {message}\")\n    # Agregar tambi√©n como INFO para asegurar que se vea\n    logger.info(f\"### DEBUG ### {message}\")\n\n# Funci√≥n para obtener proveedores con adelantos\ndef obtener_proveedores_con_adelantos():\n    \"\"\"\n    Obtiene una lista de proveedores que tienen adelantos con saldo disponible\n    \n    Returns:\n        set: Conjunto de nombres de proveedores con adelantos disponibles\n    \"\"\"\n    try:\n        debug_log(\"INICIANDO obtener_proveedores_con_adelantos\")\n        # Obtener todos los adelantos, sin filtrar\n        adelantos = get_all_data(\"adelantos\")\n        debug_log(f\"Obtenidos {len(adelantos)} registros de adelantos en total\")\n        \n        # Imprimir los primeros registros para depuraci√≥n\n        for i, adelanto in enumerate(adelantos[:3]):\n            debug_log(f\"Adelanto #{i}: {adelanto.get('proveedor')} - Saldo: {adelanto.get('saldo_restante')}\")\n        \n        # Obtener proveedores √∫nicos con saldo > 0\n        proveedores_con_adelanto = set()\n        for adelanto in adelantos:\n            try:\n                proveedor = adelanto.get('proveedor', '')\n                if not proveedor:\n                    continue\n                    \n                saldo_str = adelanto.get('saldo_restante', '0')\n                debug_log(f\"Procesando adelanto para {proveedor} con saldo_restante={saldo_str}\")\n                \n                saldo = float(saldo_str) if saldo_str else 0\n                if saldo > 0:\n                    proveedores_con_adelanto.add(proveedor)\n                    debug_log(f\"A√±adido proveedor {proveedor} con saldo {saldo}\")\n            except (ValueError, TypeError) as e:\n                debug_log(f\"Error procesando adelanto: {e} - Datos: {adelanto}\")\n                continue\n        \n        debug_log(f\"Se encontraron {len(proveedores_con_adelanto)} proveedores con adelantos disponibles: {sorted(list(proveedores_con_adelanto))}\")\n        return proveedores_con_adelanto\n    except Exception as e:\n        debug_log(f\"ERROR CR√çTICO en obtener_proveedores_con_adelantos: {e}\")\n        debug_log(traceback.format_exc())\n        # En caso de error, devolver conjunto vac√≠o para no interrumpir el flujo\n        return set()\n\nasync def compra_mixta_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Inicia el proceso de registro de compra con m√∫ltiples m√©todos de pago\"\"\"\n    user_id = update.effective_user.id\n    username = update.effective_user.username or update.effective_user.first_name\n    logger.info(f\"=== COMANDO /compra_mixta INICIADO por {username} (ID: {user_id}) ===\")\n    \n    # Inicializar datos para este usuario\n    datos_compra_mixta[user_id] = {\n        \"registrado_por\": username,\n        \"monto_efectivo\": 0,\n        \"monto_transferencia\": 0,\n        \"monto_adelanto\": 0,\n        \"adelanto_id\": \"\"\n    }\n    \n    # Pre-cargar la lista de proveedores con adelantos para tenerla ya disponible\n    # y evitar problemas de timing\n    proveedores_adelantos = obtener_proveedores_con_adelantos()\n    datos_compra_mixta[user_id][\"proveedores_con_adelanto\"] = proveedores_adelantos\n    debug_log(f\"Pre-cargados {len(proveedores_adelantos)} proveedores con adelanto para el usuario {user_id}\")\n    \n    # Crear teclado con las 3 opciones predefinidas para tipo de caf√©\n    keyboard = [[tipo] for tipo in TIPOS_CAFE]\n    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n    \n    await update.message.reply_text(\n        \"üõí *COMPRA CON PAGOS MIXTOS*\\n\\n\"\n        \"Este tipo de compra te permite utilizar diferentes formas de pago:\\n\"\n        \"- Efectivo\\n\"\n        \"- Transferencia\\n\"\n        \"- Adelantos existentes\\n\"\n        \"- O combinaciones de estos m√©todos\\n\\n\"\n        \"Selecciona el tipo de caf√©:\",\n        parse_mode=\"Markdown\",\n        reply_markup=reply_markup\n    )\n    return TIPO_CAFE\n\nasync def tipo_cafe_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Guardar el tipo de caf√© y solicitar el proveedor\"\"\"\n    user_id = update.effective_user.id\n    selected_tipo = update.message.text.strip().upper()\n    \n    # Verificar que sea uno de los tipos permitidos\n    if selected_tipo not in TIPOS_CAFE:\n        # Si no es un tipo v√°lido, volver a mostrar las opciones\n        keyboard = [[tipo] for tipo in TIPOS_CAFE]\n        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        \n        await update.message.reply_text(\n            f\"‚ùå Tipo de caf√© no v√°lido. Por favor, selecciona una de las opciones disponibles:\",\n            reply_markup=reply_markup\n        )\n        return TIPO_CAFE\n    \n    # Guardar el tipo de caf√©\n    logger.info(f\"Usuario {user_id} seleccion√≥ tipo de caf√©: {selected_tipo}\")\n    datos_compra_mixta[user_id][\"tipo_cafe\"] = selected_tipo\n    \n    # Obtener lista de proveedores con adelantos disponibles\n    # Primero verificar si ya tenemos la lista pre-cargada\n    proveedores_con_adelanto = datos_compra_mixta[user_id].get(\"proveedores_con_adelanto\", None)\n    if proveedores_con_adelanto is None:\n        debug_log(f\"Lista de proveedores no pre-cargada para usuario {user_id}, obteniendo ahora...\")\n        proveedores_con_adelanto = obtener_proveedores_con_adelantos()\n        datos_compra_mixta[user_id][\"proveedores_con_adelanto\"] = proveedores_con_adelanto\n    \n    debug_log(f\"Mostrando lista de {len(proveedores_con_adelanto)} proveedores al usuario {user_id}\")\n    \n    if proveedores_con_adelanto:\n        # Crear teclado con los proveedores que tienen adelantos\n        keyboard = [[proveedor] for proveedor in sorted(list(proveedores_con_adelanto))]\n        keyboard.append([\"Otro proveedor\"])\n        \n        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        \n        # Log de los proveedores encontrados\n        debug_log(f\"Creado teclado con proveedores: {[k[0] for k in keyboard]}\")\n        \n        await update.message.reply_text(\n            f\"‚òï Tipo de caf√©: {selected_tipo}\\n\\n\"\n            \"üìã *PROVEEDORES CON ADELANTOS DISPONIBLES:*\\n\"\n            \"Selecciona un proveedor o escribe uno nuevo:\",\n            parse_mode=\"Markdown\",\n            reply_markup=reply_markup\n        )\n        return PROVEEDOR\n    else:\n        # Si no hay proveedores con adelantos, continuar con flujo normal\n        debug_log(\"No se encontraron proveedores con adelantos disponibles, mostrando flujo normal\")\n        await update.message.reply_text(\n            f\"‚òï Tipo de caf√©: {selected_tipo}\\n\\n\"\n            \"Ahora, ingresa el nombre del proveedor:\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n        return PROVEEDOR\n\nasync def proveedor_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Guardar el proveedor y solicitar la cantidad\"\"\"\n    user_id = update.effective_user.id\n    proveedor_texto = update.message.text.strip()\n    \n    # Verificar si el usuario seleccion√≥ \"Otro proveedor\"\n    if proveedor_texto == \"Otro proveedor\":\n        debug_log(f\"Usuario {user_id} seleccion√≥ 'Otro proveedor'\")\n        await update.message.reply_text(\n            \"Escribe el nombre del proveedor:\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n        return PROVEEDOR\n    \n    # Verificar que no est√© vac√≠o\n    if not proveedor_texto:\n        await update.message.reply_text(\n            \"‚ùå Por favor, ingresa un nombre de proveedor v√°lido.\"\n        )\n        return PROVEEDOR\n    \n    logger.info(f\"Usuario {user_id} ingres√≥ proveedor: {proveedor_texto}\")\n    datos_compra_mixta[user_id][\"proveedor\"] = proveedor_texto\n    \n    # Verificar si este proveedor tiene adelantos disponibles y guardarlo para m√°s tarde\n    try:\n        adelantos = get_all_data(\"adelantos\")\n        debug_log(f\"Verificando adelantos para {proveedor_texto} - Encontrados {len(adelantos)} adelantos en total\")\n        \n        # Filtrar adelantos del proveedor con saldo\n        adelantos_proveedor = []\n        for adelanto in adelantos:\n            if adelanto.get('proveedor') == proveedor_texto:\n                try:\n                    saldo = float(adelanto.get('saldo_restante', 0))\n                    debug_log(f\"Adelanto encontrado para {proveedor_texto} con saldo {saldo}\")\n                    if saldo > 0:\n                        adelantos_proveedor.append(adelanto)\n                        debug_log(f\"A√±adido adelanto con saldo {saldo} para {proveedor_texto}\")\n                except (ValueError, TypeError) as e:\n                    debug_log(f\"Error procesando saldo: {e}\")\n                    continue\n        \n        # Calcular saldo total y guardar adelantos\n        if adelantos_proveedor:\n            saldo_total = sum(float(adelanto.get('saldo_restante', 0)) for adelanto in adelantos_proveedor)\n            datos_compra_mixta[user_id][\"tiene_adelantos\"] = True\n            datos_compra_mixta[user_id][\"adelantos_disponibles\"] = adelantos_proveedor\n            datos_compra_mixta[user_id][\"saldo_adelantos\"] = saldo_total\n            \n            debug_log(f\"El proveedor {proveedor_texto} tiene {len(adelantos_proveedor)} adelantos con saldo total {saldo_total}\")\n            \n            await update.message.reply_text(\n                f\"‚ÑπÔ∏è El proveedor {proveedor_texto} tiene adelantos vigentes \"\n                f\"por un total de {formatear_precio(saldo_total)}.\"\n            )\n        else:\n            datos_compra_mixta[user_id][\"tiene_adelantos\"] = False\n            debug_log(f\"El proveedor {proveedor_texto} no tiene adelantos con saldo\")\n            \n            # Si el usuario seleccion√≥ un proveedor de la lista pero no tiene adelantos\n            # (Esto podr√≠a pasar si los saldos cambiaron entre la carga de la lista y la selecci√≥n)\n            proveedores_con_adelanto = datos_compra_mixta[user_id].get(\"proveedores_con_adelanto\", set())\n            if proveedor_texto in proveedores_con_adelanto:\n                await update.message.reply_text(\n                    f\"‚ö†Ô∏è El proveedor {proveedor_texto} ya no tiene adelantos disponibles.\"\n                )\n    except Exception as e:\n        debug_log(f\"Error al verificar adelantos del proveedor: {e}\")\n        debug_log(traceback.format_exc())\n        datos_compra_mixta[user_id][\"tiene_adelantos\"] = False\n    \n    await update.message.reply_text(\n        f\"üë®‚Äçüåæ Proveedor: {proveedor_texto}\\n\\n\"\n        \"Ahora, ingresa la cantidad de caf√© en kg:\"\n    )\n    return CANTIDAD\n\nasync def cantidad_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Guardar la cantidad y solicitar el precio\"\"\"\n    user_id = update.effective_user.id\n    try:\n        cantidad_text = update.message.text.strip()\n        cantidad = procesar_entrada_numerica(cantidad_text)\n        \n        if cantidad <= 0:\n            await update.message.reply_text(\"‚ùå La cantidad debe ser mayor a cero. Intenta nuevamente:\")\n            return CANTIDAD\n        \n        datos_compra_mixta[user_id][\"cantidad\"] = cantidad\n        \n        await update.message.reply_text(\n            f\"üì¶ Cantidad: {formatear_numero(cantidad)} kg\\n\\n\"\n            \"Ahora, ingresa el precio por kg:\"\n        )\n        return PRECIO\n    except ValueError:\n        await update.message.reply_text(\n            \"‚ùå Por favor, ingresa un n√∫mero v√°lido para la cantidad.\"\n        )\n        return CANTIDAD\n\nasync def precio_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Guardar el precio y solicitar m√©todo de pago\"\"\"\n    user_id = update.effective_user.id\n    try:\n        precio_text = update.message.text.strip()\n        precio = procesar_entrada_numerica(precio_text)\n        \n        if precio <= 0:\n            await update.message.reply_text(\"‚ùå El precio debe ser mayor a cero. Intenta nuevamente:\")\n            return PRECIO\n        \n        datos_compra_mixta[user_id][\"precio\"] = precio\n        \n        # Calcular total\n        cantidad = datos_compra_mixta[user_id][\"cantidad\"]\n        total = calculate_total(cantidad, precio)\n        datos_compra_mixta[user_id][\"preciototal\"] = total\n        \n        # Crear teclado con m√©todos de pago disponibles\n        keyboard = []\n        \n        # Solo mostrar opciones con adelanto si el proveedor tiene adelantos disponibles\n        if datos_compra_mixta[user_id].get(\"tiene_adelantos\", False):\n            debug_log(f\"Mostrando todos los m√©todos de pago incluyendo adelantos para usuario {user_id}\")\n            metodos = METODOS_PAGO\n        else:\n            # Filtrar m√©todos que incluyen adelanto\n            debug_log(f\"Filtrando m√©todos de pago sin adelantos para usuario {user_id}\")\n            metodos = [m for m in METODOS_PAGO if \"ADELANTO\" not in m]\n        \n        for metodo in metodos:\n            keyboard.append([metodo])\n        \n        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        \n        await update.message.reply_text(\n            f\"üíµ Precio por kg: {formatear_precio(precio)}\\n\"\n            f\"üí∞ Total a pagar: {formatear_precio(total)}\\n\\n\"\n            \"Selecciona el m√©todo de pago:\",\n            reply_markup=reply_markup\n        )\n        return METODO_PAGO\n    except ValueError:\n        await update.message.reply_text(\n            \"‚ùå Por favor, ingresa un n√∫mero v√°lido para el precio.\"\n        )\n        return PRECIO\n\nasync def metodo_pago_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Procesar el m√©todo de pago seleccionado y dirigir al flujo correspondiente\"\"\"\n    user_id = update.effective_user.id\n    metodo_pago = update.message.text.strip().upper()\n    \n    # Validar que sea un m√©todo de pago v√°lido\n    metodos_validos = METODOS_PAGO\n    if not datos_compra_mixta[user_id].get(\"tiene_adelantos\", False):\n        metodos_validos = [m for m in METODOS_PAGO if \"ADELANTO\" not in m]\n    \n    if metodo_pago not in metodos_validos:\n        # Mostrar opciones v√°lidas\n        keyboard = []\n        for metodo in metodos_validos:\n            keyboard.append([metodo])\n        \n        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        \n        await update.message.reply_text(\n            \"‚ùå M√©todo de pago no v√°lido. Por favor, selecciona una de las opciones disponibles:\",\n            reply_markup=reply_markup\n        )\n        return METODO_PAGO\n    \n    # Guardar el m√©todo de pago\n    datos_compra_mixta[user_id][\"metodo_pago\"] = metodo_pago\n    debug_log(f\"Usuario {user_id} seleccion√≥ m√©todo de pago: {metodo_pago}\")\n    \n    # Determinar el siguiente paso seg√∫n el m√©todo de pago\n    if metodo_pago == \"EFECTIVO\":\n        # Si es solo efectivo, el monto es el total\n        datos_compra_mixta[user_id][\"monto_efectivo\"] = datos_compra_mixta[user_id][\"preciototal\"]\n        return await mostrar_resumen(update, context)\n    \n    elif metodo_pago == \"TRANSFERENCIA\":\n        # Si es solo transferencia, el monto es el total\n        datos_compra_mixta[user_id][\"monto_transferencia\"] = datos_compra_mixta[user_id][\"preciototal\"]\n        return await mostrar_resumen(update, context)\n    \n    elif metodo_pago == \"EFECTIVO Y TRANSFERENCIA\":\n        # Solicitar el monto en efectivo\n        await update.message.reply_text(\n            f\"üí∞ Total a pagar: {formatear_precio(datos_compra_mixta[user_id]['preciototal'])}\\n\\n\"\n            \"¬øCu√°nto se pagar√° en efectivo?\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n        return MONTO_EFECTIVO\n    \n    elif metodo_pago == \"ADELANTO\":\n        # Si es solo adelanto, redirigir a la selecci√≥n de adelanto\n        return await seleccionar_adelanto(update, context)\n    \n    elif metodo_pago == \"EFECTIVO Y ADELANTO\":\n        # Solicitar el monto en efectivo\n        await update.message.reply_text(\n            f\"üí∞ Total a pagar: {formatear_precio(datos_compra_mixta[user_id]['preciototal'])}\\n\\n\"\n            \"¬øCu√°nto se pagar√° en efectivo?\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n        return MONTO_EFECTIVO\n    \n    elif metodo_pago == \"TRANSFERENCIA Y ADELANTO\":\n        # Solicitar el monto por transferencia\n        await update.message.reply_text(\n            f\"üí∞ Total a pagar: {formatear_precio(datos_compra_mixta[user_id]['preciototal'])}\\n\\n\"\n            \"¬øCu√°nto se pagar√° por transferencia?\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n        return MONTO_TRANSFERENCIA\n\nasync def monto_efectivo_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Procesar el monto en efectivo\"\"\"\n    user_id = update.effective_user.id\n    try:\n        monto_text = update.message.text.strip()\n        monto_efectivo = procesar_entrada_numerica(monto_text)\n        \n        total = datos_compra_mixta[user_id][\"preciototal\"]\n        \n        if monto_efectivo < 0:\n            await update.message.reply_text(\"‚ùå El monto en efectivo no puede ser negativo. Intenta nuevamente:\")\n            return MONTO_EFECTIVO\n        \n        if monto_efectivo > total:\n            await update.message.reply_text(\n                f\"‚ùå El monto en efectivo no puede superar el total a pagar ({formatear_precio(total)}). \"\n                \"Intenta nuevamente:\"\n            )\n            return MONTO_EFECTIVO\n        \n        # Guardar el monto en efectivo\n        datos_compra_mixta[user_id][\"monto_efectivo\"] = monto_efectivo\n        \n        # Determinar el siguiente paso seg√∫n el m√©todo de pago\n        metodo_pago = datos_compra_mixta[user_id][\"metodo_pago\"]\n        \n        if metodo_pago == \"EFECTIVO Y TRANSFERENCIA\":\n            # Calcular el monto por transferencia autom√°ticamente\n            monto_transferencia = total - monto_efectivo\n            datos_compra_mixta[user_id][\"monto_transferencia\"] = monto_transferencia\n            \n            await update.message.reply_text(\n                f\"üíµ Monto en efectivo: {formatear_precio(monto_efectivo)}\\n\"\n                f\"üè¶ Monto por transferencia: {formatear_precio(monto_transferencia)}\"\n            )\n            \n            return await mostrar_resumen(update, context)\n        \n        elif metodo_pago == \"EFECTIVO Y ADELANTO\":\n            # Calcular el monto de adelanto autom√°ticamente\n            monto_adelanto = total - monto_efectivo\n            \n            # Verificar que hay suficiente saldo en adelantos\n            saldo_disponible = datos_compra_mixta[user_id].get(\"saldo_adelantos\", 0)\n            \n            if monto_adelanto > saldo_disponible:\n                await update.message.reply_text(\n                    f\"‚ùå El monto de adelanto requerido ({formatear_precio(monto_adelanto)}) \"\n                    f\"supera el saldo disponible ({formatear_precio(saldo_disponible)}).\\n\\n\"\n                    \"Por favor, ingresa un monto en efectivo mayor:\"\n                )\n                return MONTO_EFECTIVO\n            \n            # Guardar el monto de adelanto y pasar a selecci√≥n de adelanto\n            datos_compra_mixta[user_id][\"monto_adelanto\"] = monto_adelanto\n            \n            return await seleccionar_adelanto(update, context)\n    \n    except ValueError:\n        await update.message.reply_text(\n            \"‚ùå Por favor, ingresa un n√∫mero v√°lido para el monto en efectivo.\"\n        )\n        return MONTO_EFECTIVO\n\nasync def monto_transferencia_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Procesar el monto por transferencia\"\"\"\n    user_id = update.effective_user.id\n    try:\n        monto_text = update.message.text.strip()\n        monto_transferencia = procesar_entrada_numerica(monto_text)\n        \n        total = datos_compra_mixta[user_id][\"preciototal\"]\n        \n        if monto_transferencia < 0:\n            await update.message.reply_text(\"‚ùå El monto por transferencia no puede ser negativo. Intenta nuevamente:\")\n            return MONTO_TRANSFERENCIA\n        \n        if monto_transferencia > total:\n            await update.message.reply_text(\n                f\"‚ùå El monto por transferencia no puede superar el total a pagar ({formatear_precio(total)}). \"\n                \"Intenta nuevamente:\"\n            )\n            return MONTO_TRANSFERENCIA\n        \n        # Guardar el monto por transferencia\n        datos_compra_mixta[user_id][\"monto_transferencia\"] = monto_transferencia\n        \n        # Calcular el monto de adelanto autom√°ticamente\n        monto_adelanto = total - monto_transferencia\n        \n        # Verificar que hay suficiente saldo en adelantos\n        saldo_disponible = datos_compra_mixta[user_id].get(\"saldo_adelantos\", 0)\n        \n        if monto_adelanto > saldo_disponible:\n            await update.message.reply_text(\n                f\"‚ùå El monto de adelanto requerido ({formatear_precio(monto_adelanto)}) \"\n                f\"supera el saldo disponible ({formatear_precio(saldo_disponible)}).\\n\\n\"\n                \"Por favor, ingresa un monto por transferencia mayor:\"\n            )\n            return MONTO_TRANSFERENCIA\n        \n        # Guardar el monto de adelanto y pasar a selecci√≥n de adelanto\n        datos_compra_mixta[user_id][\"monto_adelanto\"] = monto_adelanto\n        \n        return await seleccionar_adelanto(update, context)\n    \n    except ValueError:\n        await update.message.reply_text(\n            \"‚ùå Por favor, ingresa un n√∫mero v√°lido para el monto por transferencia.\"\n        )\n        return MONTO_TRANSFERENCIA\n\nasync def seleccionar_adelanto(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Mostrar adelantos disponibles para selecci√≥n\"\"\"\n    user_id = update.effective_user.id\n    \n    # Obtener la lista de adelantos disponibles\n    adelantos = datos_compra_mixta[user_id].get(\"adelantos_disponibles\", [])\n    monto_adelanto = datos_compra_mixta[user_id].get(\"monto_adelanto\", 0)\n    \n    if not adelantos:\n        await update.message.reply_text(\n            \"‚ùå No hay adelantos disponibles para este proveedor.\"\n        )\n        return ConversationHandler.END\n    \n    # Crear teclado inline con los adelantos disponibles\n    keyboard = []\n    for adelanto in adelantos:\n        fecha = adelanto.get('fecha', '')\n        saldo = float(adelanto.get('saldo_restante', 0))\n        adelanto_id = adelanto.get('_row_index', '')\n        \n        keyboard.append([\n            InlineKeyboardButton(\n                f\"Adelanto {fecha} - {formatear_precio(saldo)}\",\n                callback_data=f\"adelanto_{adelanto_id}\"\n            )\n        ])\n    \n    reply_markup = InlineKeyboardMarkup(keyboard)\n    \n    # Si ya tenemos un monto de adelanto calculado (para m√©todos combinados)\n    if monto_adelanto > 0:\n        await update.message.reply_text(\n            f\"üí∞ Monto a pagar con adelanto: {formatear_precio(monto_adelanto)}\\n\\n\"\n            \"Selecciona el adelanto que deseas utilizar:\",\n            reply_markup=reply_markup\n        )\n    else:\n        # Para m√©todo de pago solo adelanto\n        datos_compra_mixta[user_id][\"monto_adelanto\"] = datos_compra_mixta[user_id][\"preciototal\"]\n        \n        await update.message.reply_text(\n            f\"üí∞ Total a pagar con adelanto: {formatear_precio(datos_compra_mixta[user_id]['preciototal'])}\\n\\n\"\n            \"Selecciona el adelanto que deseas utilizar:\",\n            reply_markup=reply_markup\n        )\n    \n    return SELECCIONAR_ADELANTO\n\nasync def seleccionar_adelanto_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Procesar la selecci√≥n de adelanto\"\"\"\n    query = update.callback_query\n    await query.answer()\n    \n    user_id = query.from_user.id\n    \n    # Extraer el ID del adelanto seleccionado\n    adelanto_id = query.data.replace(\"adelanto_\", \"\")\n    \n    # Guardar el ID del adelanto\n    datos_compra_mixta[user_id][\"adelanto_id\"] = adelanto_id\n    \n    # Encontrar el adelanto seleccionado\n    adelantos = datos_compra_mixta[user_id].get(\"adelantos_disponibles\", [])\n    adelanto_seleccionado = None\n    \n    for adelanto in adelantos:\n        if str(adelanto.get('_row_index', '')) == str(adelanto_id):\n            adelanto_seleccionado = adelanto\n            break\n    \n    if adelanto_seleccionado:\n        fecha = adelanto_seleccionado.get('fecha', '')\n        saldo = float(adelanto_seleccionado.get('saldo_restante', 0))\n        \n        # Verificar si hay suficiente saldo\n        monto_adelanto = datos_compra_mixta[user_id].get(\"monto_adelanto\", 0)\n        \n        if monto_adelanto > saldo:\n            # Editar el mensaje para mostrar error\n            await query.edit_message_text(\n                f\"‚ùå El adelanto seleccionado no tiene suficiente saldo.\\n\\n\"\n                f\"Saldo disponible: {formatear_precio(saldo)}\\n\"\n                f\"Monto requerido: {formatear_precio(monto_adelanto)}\\n\\n\"\n                \"Por favor, selecciona otro adelanto o cambia el m√©todo de pago.\"\n            )\n            return ConversationHandler.END\n        \n        # Editar el mensaje para mostrar confirmaci√≥n\n        await query.edit_message_text(\n            f\"‚úÖ Adelanto seleccionado: {fecha}\\n\"\n            f\"Saldo disponible: {formatear_precio(saldo)}\\n\"\n            f\"Monto a utilizar: {formatear_precio(monto_adelanto)}\"\n        )\n        \n        # Guardar informaci√≥n detallada del adelanto\n        datos_compra_mixta[user_id][\"adelanto_fecha\"] = fecha\n        datos_compra_mixta[user_id][\"adelanto_saldo\"] = saldo\n        \n        # Mostrar resumen final\n        return await mostrar_resumen(update, context)\n    else:\n        await query.edit_message_text(\"‚ùå Error al seleccionar el adelanto. Por favor, intenta nuevamente.\")\n        return ConversationHandler.END\n\nasync def mostrar_resumen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Mostrar resumen de la compra y solicitar confirmaci√≥n\"\"\"\n    user_id = update.effective_user.id if update.message else update.callback_query.from_user.id\n    \n    # Obtener los datos de la compra\n    datos = datos_compra_mixta[user_id]\n    \n    # Crear resumen\n    resumen = \"üìã *RESUMEN DE COMPRA MIXTA*\\n\\n\"\n    resumen += f\"‚òï Tipo de caf√©: {datos.get('tipo_cafe', '')}\\n\"\n    resumen += f\"üë®‚Äçüåæ Proveedor: {datos.get('proveedor', '')}\\n\"\n    resumen += f\"üì¶ Cantidad: {formatear_numero(datos.get('cantidad', 0))} kg\\n\"\n    resumen += f\"üíµ Precio por kg: {formatear_precio(datos.get('precio', 0))}\\n\"\n    resumen += f\"üí∞ Total a pagar: {formatear_precio(datos.get('preciototal', 0))}\\n\\n\"\n    \n    resumen += f\"üí≥ M√©todo de pago: {datos.get('metodo_pago', '')}\\n\"\n    \n    # A√±adir detalles seg√∫n el m√©todo de pago\n    if datos.get(\"monto_efectivo\", 0) > 0:\n        resumen += f\"üíµ Monto en efectivo: {formatear_precio(datos.get('monto_efectivo', 0))}\\n\"\n    \n    if datos.get(\"monto_transferencia\", 0) > 0:\n        resumen += f\"üè¶ Monto por transferencia: {formatear_precio(datos.get('monto_transferencia', 0))}\\n\"\n    \n    if datos.get(\"monto_adelanto\", 0) > 0:\n        resumen += f\"üí≥ Monto con adelanto: {formatear_precio(datos.get('monto_adelanto', 0))}\\n\"\n        \n        # Si hay informaci√≥n de adelanto, mostrarla\n        if datos.get(\"adelanto_fecha\", \"\"):\n            resumen += f\"üìÖ Adelanto de fecha: {datos.get('adelanto_fecha', '')}\\n\"\n            \n            # Calcular el nuevo saldo del adelanto\n            nuevo_saldo = datos.get(\"adelanto_saldo\", 0) - datos.get(\"monto_adelanto\", 0)\n            resumen += f\"üí∞ Nuevo saldo de adelanto: {formatear_precio(nuevo_saldo)}\\n\"\n    \n    # Crear teclado para confirmaci√≥n\n    keyboard = [[\"‚úÖ Confirmar\"], [\"‚ùå Cancelar\"]]\n    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n    \n    # Enviar mensaje seg√∫n el tipo de actualizaci√≥n\n    if update.message:\n        await update.message.reply_text(\n            resumen + \"\\n¬øConfirmas esta compra?\",\n            parse_mode=\"Markdown\",\n            reply_markup=reply_markup\n        )\n    else:\n        # Si venimos de un callback, enviar un nuevo mensaje\n        await context.bot.send_message(\n            chat_id=update.callback_query.message.chat_id,\n            text=resumen + \"\\n¬øConfirmas esta compra?\",\n            parse_mode=\"Markdown\",\n            reply_markup=reply_markup\n        )\n    \n    return CONFIRMAR\n\nasync def confirmar_step(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Confirmar y registrar la compra mixta\"\"\"\n    user_id = update.effective_user.id\n    respuesta = update.message.text.lower()\n    \n    if respuesta in ['s√≠', 'si', 's', 'yes', 'y', '‚úÖ confirmar', 'confirmar']:\n        try:\n            # Obtener los datos de la compra\n            datos = datos_compra_mixta[user_id].copy()\n            \n            # Generar un ID √∫nico para esta compra\n            compra_id = generate_unique_id(\"CM-\", 6)\n            datos[\"id\"] = compra_id\n            \n            # A√±adir fecha actualizada con formato protegido para Google Sheets\n            now = get_now_peru()\n            fecha_formateada = now.strftime(\"%Y-%m-%d %H:%M\")\n            datos[\"fecha\"] = format_date_for_sheets(fecha_formateada)\n            \n            # A√±adir notas vac√≠as (para mantener estructura)\n            datos[\"notas\"] = \"\"\n            \n            # Si se utiliza adelanto, actualizar el saldo del adelanto\n            if datos.get(\"monto_adelanto\", 0) > 0 and datos.get(\"adelanto_id\", \"\"):\n                try:\n                    from utils.sheets import update_cell\n                    \n                    # Calcular el nuevo saldo\n                    nuevo_saldo = datos.get(\"adelanto_saldo\", 0) - datos.get(\"monto_adelanto\", 0)\n                    \n                    # Actualizar el saldo en la hoja de adelantos\n                    update_cell(\"adelantos\", datos[\"adelanto_id\"], \"saldo_restante\", nuevo_saldo)\n                    logger.info(f\"Actualizado saldo de adelanto {datos['adelanto_id']} a {nuevo_saldo}\")\n                except Exception as e:\n                    logger.error(f\"Error al actualizar saldo de adelanto: {e}\")\n                    logger.error(traceback.format_exc())\n            \n            # 1. Guardar en la hoja de compras regular primero\n            logger.info(f\"Guardando la compra mixta en la hoja de compras regular\")\n            datos_compra_regular = {\n                \"id\": compra_id,\n                \"fecha\": datos[\"fecha\"],\n                \"tipo_cafe\": datos[\"tipo_cafe\"],\n                \"proveedor\": datos[\"proveedor\"],\n                \"cantidad\": datos[\"cantidad\"],\n                \"precio\": datos[\"precio\"],\n                \"preciototal\": datos[\"preciototal\"],\n                \"registrado_por\": datos[\"registrado_por\"],\n                \"notas\": f\"Compra mixta - M√©todo de pago: {datos['metodo_pago']}\"\n            }\n            result_compra = append_sheets(\"compras\", datos_compra_regular)\n            \n            # 2. Guardar tambi√©n en la hoja de compras_mixtas para detalles adicionales\n            logger.info(f\"Guardando compra mixta en hoja de compras_mixtas: {datos}\")\n            result_mixta = append_sheets(\"compras_mixtas\", datos)\n            \n            # 3. Registrar en almac√©n\n            logger.info(f\"Registrando la compra en almac√©n\")\n            # Corregido: Uso correcto de la funci√≥n update_almac√©n, sin esperar un tuple como retorno\n            result_almacen = update_almacen(\n                fase=datos[\"tipo_cafe\"],\n                cantidad_cambio=datos[\"cantidad\"],\n                operacion=\"sumar\",\n                notas=f\"Compra mixta ID: {compra_id}\",\n                compra_id=compra_id\n            )\n            \n            if result_compra:\n                logger.info(f\"Compra mixta guardada exitosamente para usuario {user_id}\")\n                \n                # Mensaje de √©xito\n                mensaje_exito = \"‚úÖ *¬°COMPRA MIXTA REGISTRADA EXITOSAMENTE!*\\n\\n\"\n                mensaje_exito += f\"ID: {datos['id']}\\n\"\n                mensaje_exito += f\"Proveedor: {datos['proveedor']}\\n\"\n                mensaje_exito += f\"Total: {formatear_precio(datos['preciototal'])}\\n\\n\"\n                \n                # A√±adir informaci√≥n sobre almac√©n\n                if result_almacen:\n                    mensaje_exito += \"‚úÖ Registrado en almac√©n correctamente\\n\\n\"\n                else:\n                    mensaje_exito += \"‚ö†Ô∏è La compra se registr√≥ pero hubo un error al actualizar el almac√©n\\n\\n\"\n                \n                # Informaci√≥n sobre la hoja de compras_mixtas\n                if result_mixta:\n                    mensaje_exito += \"‚úÖ Detalles del pago mixto guardados correctamente\\n\\n\"\n                else:\n                    mensaje_exito += \"‚ö†Ô∏è La compra se registr√≥ pero hubo un error al guardar los detalles del pago mixto\\n\\n\"\n                \n                mensaje_exito += \"Usa /compra_mixta para registrar otra compra.\"\n                \n                await update.message.reply_text(\n                    mensaje_exito,\n                    parse_mode=\"Markdown\",\n                    reply_markup=ReplyKeyboardRemove()\n                )\n            else:\n                logger.error(f\"Error al guardar compra mixta: La funci√≥n append_sheets devolvi√≥ False\")\n                await update.message.reply_text(\n                    \"‚ùå Error al guardar la compra. Por favor, intenta nuevamente.\\n\\n\"\n                    \"Contacta al administrador si el problema persiste.\",\n                    reply_markup=ReplyKeyboardRemove()\n                )\n        except Exception as e:\n            logger.error(f\"Error al procesar compra mixta: {e}\")\n            logger.error(traceback.format_exc())\n            \n            await update.message.reply_text(\n                \"‚ùå Error al registrar la compra. Por favor, intenta nuevamente.\\n\\n\"\n                f\"Error: {str(e)}\\n\\n\"\n                \"Contacta al administrador si el problema persiste.\",\n                reply_markup=ReplyKeyboardRemove()\n            )\n    else:\n        logger.info(f\"Usuario {user_id} cancel√≥ la compra mixta\")\n        \n        await update.message.reply_text(\n            \"‚ùå Compra cancelada.\\n\\n\"\n            \"Usa /compra_mixta para iniciar de nuevo.\",\n            reply_markup=ReplyKeyboardRemove()\n        )\n    \n    # Limpiar datos temporales\n    if user_id in datos_compra_mixta:\n        del datos_compra_mixta[user_id]\n    \n    return ConversationHandler.END\n\nasync def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n    \"\"\"Cancelar la conversaci√≥n\"\"\"\n    user_id = update.effective_user.id\n    logger.info(f\"Usuario {user_id} cancel√≥ el proceso de compra mixta con /cancelar\")\n    \n    # Limpiar datos temporales\n    if user_id in datos_compra_mixta:\n        del datos_compra_mixta[user_id]\n    \n    await update.message.reply_text(\n        \"‚ùå Operaci√≥n cancelada.\\n\\n\"\n        \"Usa /compra_mixta para iniciar de nuevo cuando quieras.\",\n        reply_markup=ReplyKeyboardRemove()\n    )\n    \n    return ConversationHandler.END\n\ndef register_compra_mixta_handlers(application):\n    \"\"\"Registra los handlers para el m√≥dulo de compra mixta\"\"\"\n    logger.info(\"Registrando handlers para compra mixta\")\n    \n    # Crear manejador de conversaci√≥n\n    compra_mixta_conv_handler = ConversationHandler(\n        entry_points=[CommandHandler(\"compra_mixta\", compra_mixta_command)],\n        states={\n            TIPO_CAFE: [MessageHandler(filters.TEXT & ~filters.COMMAND, tipo_cafe_step)],\n            PROVEEDOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, proveedor_step)],\n            CANTIDAD: [MessageHandler(filters.TEXT & ~filters.COMMAND, cantidad_step)],\n            PRECIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, precio_step)],\n            METODO_PAGO: [MessageHandler(filters.TEXT & ~filters.COMMAND, metodo_pago_step)],\n            MONTO_EFECTIVO: [MessageHandler(filters.TEXT & ~filters.COMMAND, monto_efectivo_step)],\n            MONTO_TRANSFERENCIA: [MessageHandler(filters.TEXT & ~filters.COMMAND, monto_transferencia_step)],\n            SELECCIONAR_ADELANTO: [CallbackQueryHandler(seleccionar_adelanto_callback, pattern=r'^adelanto_')],\n            CONFIRMAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, confirmar_step)],\n        },\n        fallbacks=[CommandHandler(\"cancelar\", cancelar)],\n        # A√±adir opci√≥n para permitir que se caigan las conversaciones despu√©s de cierto tiempo de inactividad\n        conversation_timeout=900  # 15 minutos - para evitar conversaciones colgadas\n    )\n    \n    # Agregar el manejador a la aplicaci√≥n\n    application.add_handler(compra_mixta_conv_handler)\n    logger.info(\"Handlers de compra mixta registrados correctamente\")\n    \n    return True